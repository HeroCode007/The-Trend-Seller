import { NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';

const productsFilePath = path.join(process.cwd(), 'lib', 'products.js');

async function readProducts() {
    try {
        const fileContent = await fs.readFile(productsFilePath, 'utf-8');
        const match = fileContent.match(/export const products = (\[[\s\S]*?\]);/);
        if (match) return eval(match[1]);
        return [];
    } catch (error) {
        console.error('Error reading products:', error);
        return [];
    }
}

async function writeProducts(products) {
    const fileContent = `// Products data - Auto-generated by Admin Panel
// Last updated: ${new Date().toISOString()}

export const products = ${JSON.stringify(products, null, 2)};

export function getProductById(id) {
    return products.find(product => product.id === id);
}

export function getProductsByCategory(category) {
    return products.filter(product => product.category === category);
}

export function getCategories() {
    return [...new Set(products.map(product => product.category))];
}
`;
    await fs.writeFile(productsFilePath, fileContent, 'utf-8');
}

function generateId() {
    return 'prod_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}

function generateProductCode(category, existingProducts) {
    const prefixes = { 'premium-watches': 'TTS-PW', 'casual-watches': 'TTS-CW', 'stylish-watches': 'TTS-SW', 'belts': 'TTS-BL', 'wallets': 'TTS-WL' };
    const prefix = prefixes[category] || 'TTS-PR';
    const categoryProducts = existingProducts.filter(p => p.productCode?.startsWith(prefix));
    let maxNum = 0;
    categoryProducts.forEach(p => {
        const numMatch = p.productCode?.match(/(\d+)$/);
        if (numMatch) { const num = parseInt(numMatch[1]); if (num > maxNum) maxNum = num; }
    });
    return `${prefix}-${String(maxNum + 1).padStart(3, '0')}`;
}

export async function GET() {
    try {
        const products = await readProducts();
        return NextResponse.json({ success: true, products });
    } catch (error) {
        console.error('Error fetching products:', error);
        return NextResponse.json({ success: false, error: 'Failed to fetch products' }, { status: 500 });
    }
}

export async function POST(request) {
    try {
        const body = await request.json();
        const { name, productCode, price, category, description, image, images, features, inStock } = body;

        if (!name || !price || !category) {
            return NextResponse.json({ success: false, error: 'Name, price, and category are required' }, { status: 400 });
        }

        const products = await readProducts();

        const newProduct = {
            id: generateId(),
            productCode: productCode || generateProductCode(category, products),
            name, price: parseFloat(price), category,
            description: description || '',
            image: image || '/images/placeholder.png',
            images: images || [],
            features: features || [],
            inStock: inStock !== false
        };

        products.push(newProduct);
        await writeProducts(products);

        return NextResponse.json({ success: true, product: newProduct });
    } catch (error) {
        console.error('Error creating product:', error);
        return NextResponse.json({ success: false, error: 'Failed to create product' }, { status: 500 });
    }
}
